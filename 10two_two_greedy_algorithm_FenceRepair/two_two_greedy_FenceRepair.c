//長い板からN個の板を切り出します。
//切り出す板の長さはL1,L2,....,LNであり、元の板の長さはちょうどこれらの合計です。
//板を切断する際には、切断する板の長さ分のコストがかかります。
//すべての板を切り出す場合、最小でどれだけのコストがかかりますか。
//（コストの例）
//21の板を13と8に切断→21のコスト
//13の板を5と8に切断→13のコスト

//このアルゴリズムの答え
//切り出し方は、二分木で表すことができる。
//「１番目に短い板と２番目に短い板の接点は兄弟として良い」という性質がある。
//切り出し後に１番目に短い板(mii1)と２番目に短い板(mii2)は、切り出す際には、それぞれの長さを足したコストが発生したはず。
//mii1とmii2を切り出し前に戻し、再度、１番目に短い板と２番目に短い板をチェックし、それぞれの長さを足し、コストに加える。
//この処理を再帰的に解くことで答えを出す。
//今回のアルゴリズムはO(N*N)になってしまうが、O(NlogN)で解く方法もある。


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void swap(int mii1,int mii2);

int main(void)
{
    int N;
    int L[]={8,5,8};
    long long answer =0;
    N = 3;

    //板が1本になるまで
    while(N>1){

        //一番短い板mii1、その次に短い板mii2を求める
        int mii1 = 0, mii2 = 1;
        if(L[mii1] > L[mii2])
        {
            swap(mii1,mii2);
        }

        for (int i=2;i<N;i++)
        {
            //forで回して、一番短い板(L)をmii1に代入。
            //if文に引っかからない場合は↑の処理ですでに
            //mii1が一番短く、mii2に二番目に短い板が代入されてる
            if(L[i]<L[mii1])
            {
                mii2=mii1;
                mii1=i;
            }
            //mii1は求まっていて、mii2は求まっていないパターン。
            //２番目に短い板(L)をmii2に代入
            else if(L[i]<L[mii2])
            {
                mii2=i;
            }
        }
        //ここまでで１番目に短い板、２番目に短い板を求めた。



        //１番短い板と２番目に短い板を足した物がコスト
        int t = L[mii1] + L[mii2];
        answer += t ;

        if(mii1 == N-1)
        {
            swap(mii1,mii2);
        }

        //mii1を切断前の値tに戻す
        L[mii1] = t;

        //mii2にL[N-1]を代入
        L[mii2] = L[N-1];

        //mii1が切断前に戻ったので、板の個数(N)も一つ減らす。
        //板の個数(N)が一つになるまで（すべての板を切断前に戻すまで）処理を繰り返す
        N--;
    }

    printf("%lld\n",answer);

}


void swap(int mii1,int mii2)
{
	int temp;
	temp = mii1;
	mii1 = mii2;
	mii2 = temp;
	
    return;

}